<?php

namespace OSC\Commands;

use Ahc\Cli\Application as App;
use Ahc\Cli\Input\Command;
use OSC\Manager\Module\Manager as ModuleRepositoryManager;
use OSC\Omeka\OmekaDotOrgApi;
use OSC\Omeka\OmekaInstance;
use OSC\Omeka\OmekaInstanceFactory;

abstract class AbstractCommand extends Command
{
    protected static OmekaInstance $omeka;

    protected ModuleRepositoryManager $moduleRepositoryManager;
    protected OmekaDotOrgApi $webApi;

    public function __construct(string $_name, string $_desc = '', bool $_allowUnknown = false, ?App $_app = null)
    {
        parent::__construct($_name, $_desc, $_allowUnknown, $_app);

        $this->moduleRepositoryManager = ModuleRepositoryManager::getInstance();
        $this->webApi = OmekaDotOrgApi::getInstance(); // todo: remove (or replace with themeRepositoryManager)
    }

    public function defaults(): Command
    {
        parent::defaults(); // TODO: Change the autogenerated stub

        // set default verbosity
        $this->set('verbosity', 1);

        // add omeka base-path option
        $this->option('-b --base-path', 'Base path to Omeka S installation', 'strval');
        $this->option('-q --quiet', 'Suppress info messages', 'strval')->on([$this, 'beQuiet']);

        return $this;
    }

    public function optionEnv(): self {
        $this->option('-e --env', 'Output ENV variable', 'boolval', false)->on([$this, 'beQuiet']);
        return $this;
    }

    public function optionTable(): self {
        $this->option('-t --table', 'Output text table', 'boolval', false)->on([$this, 'beQuiet']);
        return $this;
    }

    public function optionJson(): self {
        $this->option('-j --json', 'Output json', 'boolval', false)->on([$this, 'beQuiet']);
        return $this;
    }

    public function optionExtended(): self {
        $this->option('-x --extended', 'Extended output', 'boolval', false);
        return $this;
    }

    public function getOutputFormat($defaultFormat = null) {
        $values = $this->values();
        $supportedFormats = ['json', 'table', 'env'];

        $format = $defaultFormat;
        foreach($supportedFormats as $supportedFormat) {
            if ($values[$supportedFormat] ?? null) {
                $format = $supportedFormat;
                break;
            }
        }

        return $format;
    }

    // messages
    public function warn(string $message, bool $eol = false): void
    {
        if ($this->values()['verbosity'] > 0) {
            $this->io()->warn($message, $eol);
        }
    }

    public function info(string $message, bool $eol = false): void
    {
        if ($this->values()['verbosity'] > 0) {
            $this->io()->info($message, $eol);
        }
    }

    public function ok(string $message, bool $eol = false): void
    {
        if ($this->values()['verbosity'] > 0) {
            $this->io()->ok($message, $eol);
        }
    }

    public function echo(string $message, bool $eol = false): void
    {
        $this->io()->writer()->raw($message);
        if ($eol) {
            $this->io()->eol();
        }
    }

    public function beQuiet() {
        $this->set('verbosity', 0);
    }

    public function outputFormatted($object, $format='json', $return_value = false): ?string
    {
        if(!$object)
            return null;
        if($return_value)
            ob_start();
        switch($format){
            case 'raw':
                $this->io()->writer()->raw($object);
                break;
            case 'table': $this->io()->table($object); break;
            case 'print_r': $this->io()->writer()->raw(print_r($object, true)); break;
            case 'var_export': $this->io()->writer()->raw(var_export($object, true)); break;
            case 'json':
            default:
                if(is_object($object))
                    $object = (array)$object;
                $this->io()->writer()->raw(json_encode($object, JSON_PRETTY_PRINT));
                $this->io()->eol();
                break;
        }
        if($return_value)
            return ob_get_clean();

        return null;
    }

    protected function getOmekaPath(): string {
        static $basePath = null;
        if ($basePath) {
            return $basePath;
        }

        $basePath = $this->values()['basePath'] ?? null;
        if ($basePath) {
            $basePath = rtrim($basePath, DIRECTORY_SEPARATOR);
            if (!$this->isOmekaDir($basePath)) {
                throw new \Exception("The provided base path {$basePath} does not contain a valid Omeka S context.");
            }
        } else {
            $basePath = $this->searchOmekaDir();
            if (!$basePath) {
                throw new \Exception("Could not find a valid Omeka S context.");
            }
        }

        $this->info("Omeka S found at {$basePath}", true);

        return $basePath;
    }

    protected function getOmekaInstance(bool $elevated = true): OmekaInstance {
        $instance = OmekaInstanceFactory::createInstance($this->getOmekaPath());
        if ($elevated) {
            // check if omeka is installed
            if (!$instance->getStatus()->isInstalled()) {
                throw new \Exception("Omeka S is not installed.");
            }
            $instance->elevatePrivileges();
        }
        return $instance;
    }

    protected function getModuleRepositoryManager(): ModuleRepositoryManager {
        return $this->moduleRepositoryManager;
    }

    # check for
    # - /config/database.ini
    # - /bootstrap.php
    # - /application/config/application.config.php
    protected function isOmekaDir($dir): bool
    {
        $dir = rtrim($dir, DIRECTORY_SEPARATOR);
        if (
            file_exists( join(DIRECTORY_SEPARATOR, [$dir, '/bootstrap.php']))
            && file_exists( join(DIRECTORY_SEPARATOR, [$dir, '/application/config/application.config.php']))
            && file_exists(join(DIRECTORY_SEPARATOR, [$dir, '/modules']))
            && file_exists(join(DIRECTORY_SEPARATOR, [$dir, '/themes']))
            && file_exists(join(DIRECTORY_SEPARATOR, [$dir, '/files']))
        )
        {
            return true;
        }
        return false;
    }

    // search for Omeka S context from current directory
    private function searchOmekaDir(): ?string
    {
        $dir = realpath('.');
        while ($dir !== false && $dir !== '/' && !$this->isOmekaDir($dir)) {
            $dir = realpath($dir . '/..');
        }

        if ($dir !== false && $dir !== '/') {
            return $dir;
        }

        return null;
    }
}